(()=>{var n=document.getElementById("canvas");n.width=window.innerWidth,n.height=window.innerHeight;var t=n.getContext("webgl");t||console.error("Unable to initialize WebGL.");var e=0;function o(n,e){var o=t.createShader(e);if(t.shaderSource(o,n),t.compileShader(o),!t.getShaderParameter(o,t.COMPILE_STATUS))throw"Shader compile failed with: "+t.getShaderInfoLog(o);return o}function i(n,e){var o=t.getUniformLocation(n,e);if(-1===o)throw"Cannot find uniform "+e+".";return o}window.addEventListener("resize",(function(){n.width=window.innerWidth,n.height=window.innerHeight,t.viewport(0,0,n.width,n.height),t.uniform1f(f,window.innerWidth),t.uniform1f(p,window.innerHeight)}),!1);var a=o("\nattribute vec2 position;\nvoid main() {\n\tgl_Position = vec4(position, 0.0, 1.0);\n}\n",t.VERTEX_SHADER),r=o("\nprecision highp float;\n\nuniform float width;\nuniform float height;\nvec2 resolution = vec2(width, height);\n\nuniform float time;\n\n//Base values modified with depth later\nfloat intensity = 1.0;\nfloat radius = 0.05;\n\n//Distance functions from \n//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat triangleDist(vec2 p){ \n\tconst float k = sqrt(3.0);\n  p.x = abs(p.x) - 1.0;\n  p.y = p.y + 1.0/k;\n  if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\nfloat boxDist(vec2 p){\n  vec2 d = abs(p)-1.0;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat circleDist( vec2 p){\n  return length(p) - 1.0;\n}\n\n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n  return pow(radius/dist, intensity);\n}\n\nvoid main(){\n    \n\tvec2 uv = gl_FragCoord.xy/resolution.xy;\n  float widthHeightRatio = resolution.x/resolution.y;\n  vec2 centre;\n  vec2 pos;\n\t\n  float t = time * 0.05;\n    \n  float dist;\n  float glow;\n  vec3 col = vec3(0);\n    \n  //The spacing between shapes\n  float scale = 500.0;\n  //Number of shapes\n  const float layers = 15.0;\n    \n  float depth;\n  vec2 bend;\n    \n  vec3 purple = vec3(0.611, 0.129, 0.909);\n  vec3 green = vec3(0.133, 0.62, 0.698);\n    \n  float angle;\n  float rotationAngle;\n  mat2 rotation;\n    \n  //For movement of the anchor point in time\n  float d = 2.5*(sin(t) + sin(3.0*t));\n\n  //Create an out of frame anchor point where all shapes converge to    \n  vec2 anchor = vec2(0.5 + cos(d), 0.5 + sin(d));\n    \n  //Create light purple glow at the anchor loaction\n  pos = anchor - uv;\n  pos.y /= widthHeightRatio;\n  dist = length(pos);\n  glow = getGlow(dist, 0.2, 1.9);\n  col += glow * vec3(0.7,0.6,1.0);\n    \n\tfor(float i = 0.0; i < layers; i++){\n        \n  \t//Time varying depth information depending on layer\n    depth = fract(i/layers + t);\n\n    //Move the focus of the camera in a circle\n    centre = vec2(0.5 + 0.2 * sin(t), 0.5 + 0.2 * cos(t));\n        \n   \t//Position shapes between the anchor and the camera focus based on depth\n   \tbend = mix(anchor, centre, depth);\n     \t\n    pos = bend - uv;\n   \tpos.y /= widthHeightRatio;\n\n    //Rotate shapes\n    rotationAngle = 3.14 * sin(depth + fract(t) * 6.28) + i;\n    rotation = mat2(cos(rotationAngle), -sin(rotationAngle), \n                    sin(rotationAngle),  cos(rotationAngle));\n        \n    pos *= rotation;\n        \n    //Position shapes according to depth\n    pos *= mix(scale, 0.0, depth);\n    \t\n    float m = mod(i, 3.0);\n    if(m == 0.0){\n    \tdist = abs(boxDist(pos));\n    }else if(m == 1.0){\n      dist = abs(triangleDist(pos));\n    }else{\n    \tdist = abs(circleDist(pos));\n    }\n       \n    //Get glow from base radius and intensity modified by depth\n    glow = getGlow(dist, radius+(1.0-depth)*2.0, intensity + depth);\n        \n    //Find angle along shape and map from [-PI; PI] to [0; 1]\n    angle = (atan(pos.y, pos.x)+3.14)/6.28;\n    //Shift angle depending on layer and map to [1...0...1]\n\t\tangle = abs((2.0*fract(angle + i/layers)) - 1.0);\n        \n    //White core\n   \t//col += 10.0*vec3(smoothstep(0.03, 0.02, dist));\n        \n    //Glow according to angle value\n    col += glow * mix(green, purple, angle);\n\t}\n    \n  //Tone mapping\n  col = 1.0 - exp(-col);\n    \n  //Output to screen\n  gl_FragColor = vec4(col,1.0);\n}\n",t.FRAGMENT_SHADER),s=t.createProgram();t.attachShader(s,a),t.attachShader(s,r),t.linkProgram(s),t.useProgram(s);var l=new Float32Array([-1,1,-1,-1,1,1,1,-1]),d=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,d),t.bufferData(t.ARRAY_BUFFER,l,t.STATIC_DRAW);var c=function(n,e){var o=t.getAttribLocation(n,e);if(-1===o)throw"Cannot find attribute position.";return o}(s,"position");t.enableVertexAttribArray(c),t.vertexAttribPointer(c,2,t.FLOAT,!1,8,0);var h=i(s,"time"),f=i(s,"width"),p=i(s,"height");t.uniform1f(f,window.innerWidth),t.uniform1f(p,window.innerHeight),function n(){e+=.015,t.uniform1f(h,e),t.drawArrays(t.TRIANGLE_STRIP,0,4),requestAnimationFrame(n)}()})();